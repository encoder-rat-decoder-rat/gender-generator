{"version":3,"sources":["GooeyShader.frag","GooeyFilter.js","faceDrawing.js","utils.js","mediaSource.js","generateFace.js","downloadFrame.js","index.js"],"names":["GooeyFilter","threshold","Filter","defaulVertexSrc","fragment","_threshold","uniforms","uThreshold","value","this","faceLandmarksDetection","require","irisUVCoords","468","469","470","471","472","473","474","475","476","477","index","UV_COORDS","getSizeFromBoundingBox","topLeft","bottomRight","width","height","getContainerSize","app","prediction","container","boundingBox","scale","Math","max","renderer","getCirclePosition","point","x","y","convertUVToContainer","convertMeshToRelative","scaledMesh","createPoint","size","spritesheet","seededRandom","circle","Graphics","beginFill","drawCircle","endFill","position","set","textureKey","_frameKeys","round","length","iconTexture","textures","icon","Sprite","anchor","finalScale","min","redrawFace","faceContainer","featureContainer","pivot","key","feature","getChildByName","includes","MESH_ANNOTATIONS","forEach","pointIndex","featurePoint","getChildAt","getLocalBounds","drawFace","sizeFactor","iconContainer","Container","name","featureIcons","circlePosition","visible","addChild","rotation","modelSingleton","getFaceFromMedia","video","a","load","SupportedPackages","mediapipeFacemesh","estimateFaces","input","predictIrises","luminanace","r","g","b","map","v","pow","contrast","rgb1","rgb2","lum1","lum2","startWebcam","navigator","mediaDevices","getUserMedia","audio","facingMode","stream","document","createElement","Promise","resolve","reject","addEventListener","play","srcObject","console","error","setUpMoveOnTick","displayObject","scaleTo","Point","positionTo","rotationTo","moveOnTick","rateOverrides","rates","positionX","positionY","scaleX","scaleY","moveInstantly","createEye","eye","drawEllipse","outline","lineStyle","color","alignment","eyeMask","iris","mask","rotateFace","PI","turnFace","mouth","nose","leftEye","rightEye","direction","abs","openMouth","moveIris","leftIris","rightIris","xPosition","yPosition","isBlinking","generateFaceCanvas","Application","backgroundColor","sharedTicker","antialias","start","arc","stage","render","Ticker","shared","add","tickSeed","window","setTimeout","blink","view","downloadCanvasAsPNG","canvas","filename","toBlob","blob","URL","createObjectURL","url","body","appendChild","setAttribute","click","remove","settings","FAIL_IF_MAJOR_PERFORMANCE_CAVEAT","PREFER_ENV","ENV","WEBGL_LEGACY","FILTER_RESOLUTION","fgColorArray","whiteTextureUrl","process","queryParams","URLSearchParams","location","search","seed","parseInt","get","page","seedrandom","isDownload","has","Number","innerWidth","innerHeight","bgColorArray","isContrastRatioAcceptable","bgColor","utils","rgb2hex","fgColor","sharedLoader","resizeTo","undefined","faceSource","info","whiteTexture","Loader","resources","texture","whiteSpriteSheet","Spritesheet","spritesheetJSON","all","parse","blurFilter","filters","BlurFilter","blur","quality","gooeyFilter","dotFilter","DotFilter","colorReplace","MultiColorReplaceFilter","predictions","fps"],"mappings":"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","file":"static/js/main.78c1f93a.chunk.js","sourcesContent":["export default \"// Based on Waterdrop shader from https://codepen.io/stefanweck/pen/Vbgeax\\nprecision highp float;\\n#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\nuniform float uThreshold;\\n\\nvoid main(void) {\\n    vec4 color = texture2D(uSampler, vTextureCoord);\\n    color.a = step(uThreshold, color.a);\\n    gl_FragColor = color;\\n}\";","import { Filter } from \"pixi.js\";\n\nimport fragment from \"./GooeyShader.frag\";\n\nclass GooeyFilter extends Filter {\n  constructor(threshold = 0.2) {\n    super(Filter.defaulVertexSrc, fragment);\n    this._threshold = threshold;\n    this.uniforms.uThreshold = this._threshold;\n  }\n\n  /**\n   * Sets the threshold for the amount of goooooo\n   *\n   * @member {Number}\n   * @default 0\n   */\n  set threshold(value) {\n    this._threshold = value;\n    this.uniforms.uThreshold = value;\n  }\n  get threshold() {\n    return this._threshold;\n  }\n}\n\nexport default GooeyFilter;\n","import { Container, Graphics, Sprite } from \"pixi.js\";\nimport { UV_COORDS } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/uv_coords.js\";\nimport { MESH_ANNOTATIONS } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/keypoints.js\";\nconst faceLandmarksDetection = require(\"@tensorflow-models/face-landmarks-detection\");\n\n// Add default UVs for Irises (they are not currently provided)\nconst irisUVCoords = {\n  // Left Iris\n  468: [0.576, 0.426],\n  469: [0.567, 0.425],\n  470: [0.578, 0.416],\n  471: [0.586, 0.427],\n  472: [0.574, 0.436],\n  // Right Iris\n  473: [0.418, 0.427],\n  474: [0.432, 0.426],\n  475: [0.417, 0.414],\n  476: [0.404, 0.429],\n  477: [0.42, 0.44],\n};\nfor (const index in irisUVCoords) {\n  UV_COORDS[index] = irisUVCoords[index];\n}\n\n/**\n * Gets the size from out tensor flow bounding box\n *\n * @param {Object} boundingBox\n * @param {Number} boundingBox.topLeft The top left coordinate of the container\n * @param {Number} boundingBox.bottomRight The bottom right coordinate of the container\n */\nexport function getSizeFromBoundingBox({ topLeft, bottomRight }) {\n  return {\n    width: bottomRight[0] - topLeft[0],\n    height: bottomRight[1] - topLeft[1],\n  };\n}\n\n/**\n * The UV coords are normalized in terms of 0 -> 1 of the container\n * Convert the relative values to pixels in the container\n *\n * @param {Array} point\n * @param {Number} point[0] The x value of the point\n * @param {Number} point[1] The y value of the point\n * @param {Array} containerSize\n * @param {Number} containerSize[0] The width value of the container\n * @param {Number} containerSize[1] The height value of the container\n */\nfunction convertUVToContainer([x, y], [width, height]) {\n  return [x * width, y * height];\n}\n\n/**\n * Converts the tensor flow mesh to a relative (0->1) position\n *\n * @param {Array} point\n * @param {Number} point[0] The x value of the point\n * @param {Number} point[1] The y value of the point\n * @param {Object} boundingBox\n * @param {Number} boundingBox.topLeft The top left coordinate of the container\n * @param {Number} boundingBox.bottomRight The bottom right coordinate of the container\n */\nfunction convertMeshToRelative([x, y], boundingBox) {\n  const { width, height } = getSizeFromBoundingBox(boundingBox);\n  return [\n    (x - boundingBox.topLeft[0]) / width,\n    (y - boundingBox.topLeft[1]) / height,\n  ];\n}\n\nfunction getContainerSize(app, prediction) {\n  let container = [];\n  if (prediction) {\n    const { width, height } = getSizeFromBoundingBox(prediction.boundingBox);\n    const scale = Math.max(\n      app.renderer.width / width,\n      app.renderer.height / height\n    );\n    container = [width * scale, height * scale];\n  } else {\n    container = [app.renderer.width, app.renderer.height];\n  }\n\n  return container;\n}\n\nfunction getCirclePosition(point, prediction, container) {\n  // If the point is an array it's xyz coords, otherwise it's an index reference to UV_COORDS\n  let relativeCoords = [];\n  if (prediction) {\n    relativeCoords = convertMeshToRelative(\n      prediction.scaledMesh[point],\n      prediction.boundingBox\n    );\n  } else {\n    relativeCoords = UV_COORDS[point];\n  }\n  return convertUVToContainer(relativeCoords, container);\n}\n\n/**\n * Add a point on the face mesh\n */\nexport function createPoint(point, size, spritesheet, seededRandom) {\n  const circle = new Graphics()\n    .beginFill(0xffffff * seededRandom())\n    .drawCircle(0, 0, size)\n    .endFill();\n  // TODO: reposition on window resize\n  circle.position.set(...point);\n\n  const textureKey =\n    spritesheet._frameKeys[\n      Math.round((spritesheet._frameKeys.length - 1) * seededRandom())\n    ];\n  const iconTexture = spritesheet.textures[textureKey];\n  const icon = new Sprite(iconTexture);\n  icon.anchor.set(0.5, 0.5);\n  icon.position.set(circle.x, circle.y);\n  icon.finalScale =\n    (size * 1.1) / Math.min(iconTexture.width, iconTexture.height);\n  icon.scale.set(icon.finalScale);\n\n  // Store the circle so we can reference it in the animation\n  icon.circle = circle;\n  circle.icon = icon;\n\n  return [circle, icon];\n}\n\nexport function redrawFace({\n  app,\n  faceContainer,\n  featureContainer,\n  prediction,\n}) {\n  const container = getContainerSize(app, prediction);\n\n  // Center the face in the window, but move it slowly to reduce jitter\n  faceContainer.pivot.set(\n    faceContainer.pivot.x - (faceContainer.pivot.x - container[0] / 2) * 0.1,\n    faceContainer.pivot.y - (faceContainer.pivot.y - container[1] / 2) * 0.1\n  );\n  faceContainer.position.set(\n    faceContainer.position.x -\n      (faceContainer.position.x - app.renderer.width / 2) * 0.1,\n    faceContainer.position.y -\n      (faceContainer.position.y - app.renderer.height / 2) * 0.1\n  );\n\n  for (const key in MESH_ANNOTATIONS) {\n    const feature = featureContainer.getChildByName(key);\n    // Don't draw the silhouette\n    if (!key.includes(\"silhouette\")) {\n      MESH_ANNOTATIONS[key].forEach((point, pointIndex) => {\n        const featurePoint = feature.getChildAt(pointIndex);\n\n        const position = getCirclePosition(point, prediction, container);\n\n        // Move slowly to the point to reduce jitter\n        featurePoint.position.set(\n          featurePoint.position.x -\n            (featurePoint.position.x - position[0]) * 0.1,\n          featurePoint.position.y -\n            (featurePoint.position.y - position[1]) * 0.1\n        );\n        featurePoint.icon.position.set(featurePoint.x, featurePoint.y);\n      });\n    }\n  }\n\n  const { width, height } = faceContainer.getLocalBounds();\n  // Set the scale so at least some of the edges touch the sides\n  const scale =\n    Math.min(app.renderer.width / width, app.renderer.height / height) * 1.05;\n  // Scale it slowly to reduce jitter\n  faceContainer.scale.set(\n    faceContainer.scale.x - (faceContainer.scale.x - scale) * 0.1\n  );\n}\n\nexport function drawFace({\n  app,\n  seededRandom,\n  sizeFactor,\n  spritesheet,\n  faceContainer,\n  featureContainer,\n  iconContainer,\n  prediction,\n}) {\n  const container = getContainerSize(app, prediction);\n\n  // Center the face in the window\n  faceContainer.pivot.set(container[0] / 2, container[1] / 2);\n  faceContainer.position.set(app.renderer.width / 2, app.renderer.height / 2);\n\n  // Add all of the important points\n  for (const key in MESH_ANNOTATIONS) {\n    // Don't draw the silhouette\n    if (!key.includes(\"silhouette\")) {\n      const feature = new Container();\n      feature.name = key;\n      const featureIcons = new Container();\n      featureIcons.name = `${key}_icons`;\n\n      MESH_ANNOTATIONS[key].forEach((point, pointIndex) => {\n        const circlePosition = getCirclePosition(point, prediction, container);\n\n        // Grow size proportional to the page size\n        const size = seededRandom() * sizeFactor;\n\n        const [circle, icon] = createPoint(\n          circlePosition,\n          size,\n          spritesheet,\n          seededRandom\n        );\n\n        // Hide icon if the size is smaller than 1/3rd of the sizeFactor for visual fidelity\n        if (size < sizeFactor / 3) {\n          icon.visible = false;\n        }\n\n        circle.name = pointIndex;\n        icon.name = pointIndex;\n        feature.addChild(circle);\n        featureIcons.addChild(icon);\n      });\n\n      featureIcons.position = feature.position;\n      featureIcons.pivot = feature.pivot;\n      featureIcons.scale = feature.scale;\n      featureIcons.rotation = feature.rotation;\n\n      featureContainer.addChild(feature);\n      iconContainer.addChild(featureIcons);\n    }\n  }\n\n  const { width, height } = faceContainer.getLocalBounds();\n  // Set the scale so at least some of the edges touch the sides\n  const scale =\n    Math.min(app.renderer.width / width, app.renderer.height / height) * 1.05;\n  // Scale it slowly to reduce jitter\n  faceContainer.scale.set(scale);\n}\n\nlet modelSingleton = null;\nexport async function getFaceFromMedia(video) {\n  if (!modelSingleton) {\n    modelSingleton = await faceLandmarksDetection.load(\n      faceLandmarksDetection.SupportedPackages.mediapipeFacemesh\n    );\n  }\n\n  return modelSingleton.estimateFaces({\n    input: video,\n    predictIrises: true,\n  });\n}\n","/**\n * Calculate the luminance (the intensity of light or brightness) of a color\n * https://stackoverflow.com/questions/9733288/how-to-programmatically-calculate-the-contrast-ratio-between-two-colors\n *\n * @param {Number} r The Red value from 0.0 to 1.0\n * @param {Number} g The Green value from 0.0 to 1.0\n * @param {Number} b The Blue value from 0.0 to 1.0\n */\nexport function luminanace(r, g, b) {\n  const a = [r * 255, g * 255, b * 255].map((v) => {\n    v /= 255;\n    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\n  });\n  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\n}\n\n/**\n * Calculate the contrast ratio of two color arrays\n * https://stackoverflow.com/questions/9733288/how-to-programmatically-calculate-the-contrast-ratio-between-two-colors\n * @param {Number[]} rgb1 A color array in a [r,g,b] format from 0.0 to 1.0\n * @param {Number[]} rgb2 A color array in a [r,g,b] format from 0.0 to 1.0\n */\nexport function contrast(rgb1, rgb2) {\n  const lum1 = luminanace(rgb1[0], rgb1[1], rgb1[2]);\n  const lum2 = luminanace(rgb2[0], rgb2[1], rgb2[2]);\n  const brightest = Math.max(lum1, lum2);\n  const darkest = Math.min(lum1, lum2);\n  return (brightest + 0.05) / (darkest + 0.05);\n}\n","export async function startWebcam() {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: false,\n      video: {\n        facingMode: \"user\",\n      },\n    });\n    const video = document.createElement(\"video\");\n    // TODO: Reject on timeout\n    await new Promise((resolve, reject) => {\n      video.addEventListener(\"loadedmetadata\", async () => {\n        await video.play();\n        resolve();\n      });\n      video.srcObject = stream;\n    });\n\n    return video;\n  } catch (error) {\n    console.error(\"Cannot access a webcam: \", error);\n    // Re-raise the error\n    throw error;\n  }\n}\n","import { Application, Graphics, Point, Ticker } from \"pixi.js\";\n\n/**\n * Sets up transform properties used for animations on each tick\n *\n * @param {PIXI.DisplayObject} displayObject\n */\nfunction setUpMoveOnTick(displayObject) {\n  displayObject.scaleTo = new Point(\n    displayObject.scale.x,\n    displayObject.scale.y\n  );\n  displayObject.positionTo = new Point(\n    displayObject.position.x,\n    displayObject.position.y\n  );\n  displayObject.rotationTo = displayObject.rotation;\n}\n\n/**\n * The function that processes that animations and moves on each tick\n *\n * @param {PIXI.DisplayObject} displayObject\n * @param {Object} rateOverrides The object of various rates of change for each transform\n * @param {Number} rateOverrides.positionX The rate of change for the position X property\n * @param {Number} rateOverrides.positionY The rate of change for the position Y property\n * @param {Number} rateOverrides.scaleX The rate of change for the scale X property\n * @param {Number} rateOverrides.scaleY The rate of change for the scale Y property\n * @param {Number} rateOverrides.rotation The rate of change for the rotation property\n */\nfunction moveOnTick(displayObject, rateOverrides = {}) {\n  const rates = {\n    positionX: 0.1,\n    positionY: 0.1,\n    scaleX: 0.1,\n    scaleY: 0.1,\n    rotation: 0.1,\n    ...rateOverrides,\n  };\n  displayObject.position.set(\n    displayObject.position.x -\n      (displayObject.position.x - displayObject.positionTo.x) * rates.positionX,\n    displayObject.position.y -\n      (displayObject.position.y - displayObject.positionTo.y) * rates.positionY\n  );\n  displayObject.scale.set(\n    displayObject.scale.x -\n      (displayObject.scale.x - displayObject.scaleTo.x) * rates.scaleX,\n    displayObject.scale.y -\n      (displayObject.scale.y - displayObject.scaleTo.y) * rates.scaleY\n  );\n  displayObject.rotation =\n    displayObject.rotation -\n    (displayObject.rotation - displayObject.rotationTo) * rates.rotation;\n}\n\n/**\n * Sets the *To values instantly instead of over time\n *\n * @param {PIXI.DisplayObject} displayObject\n */\nfunction moveInstantly(displayObject) {\n  displayObject.position.set(\n    displayObject.positionTo.x,\n    displayObject.positionTo.y\n  );\n  displayObject.scale.set(displayObject.scaleTo.x, displayObject.scaleTo.y);\n  displayObject.rotation = displayObject.rotationTo;\n}\n\n/**\n * Creates a fake eye object with an iris\n *\n * @param {Number} x The X position of the eye\n * @param {Number} y The Y position of the eye\n * @param {Number} rotation The rotation of the eye (in radians)\n */\nfunction createEye(x, y, rotation) {\n  const eye = new Graphics();\n  eye.beginFill(0xffffff).drawEllipse(0, 0, 60, 30).endFill();\n\n  eye.position.set(x, y);\n  eye.rotation = rotation;\n  setUpMoveOnTick(eye);\n\n  const outline = new Graphics();\n  outline\n    .lineStyle({ width: 2, color: 0x000000, alignment: 0 })\n    .drawEllipse(0, 0, 60, 30);\n\n  const eyeMask = new Graphics();\n  eyeMask.beginFill(0x000000).drawEllipse(0, 0, 60, 30);\n\n  const iris = new Graphics();\n  iris.beginFill(0x005555).drawCircle(0, 0, 15).endFill();\n\n  setUpMoveOnTick(iris);\n\n  eye.addChild(outline, iris, eyeMask);\n  eye.mask = eyeMask;\n  eye.iris = iris;\n  eye.outline = outline;\n\n  return eye;\n}\n\n/**\n * Rotate the face randomly\n *\n * @param {PIXI.Container} faceContainer\n * @param {function} seededRandom\n */\nfunction rotateFace(faceContainer, seededRandom) {\n  faceContainer.rotationTo = (Math.PI / 3) * seededRandom() - Math.PI / 6;\n}\n\n/**\n * Turn the face from side to side randomly\n *\n * @param {PIXI.Container} faceContainer\n * @param {PIXI.Graphics} mouth\n * @param {PIXI.Graphics} nose\n * @param {PIXI.Graphics} leftEye\n * @param {PIXI.Graphics} rightEye\n * @param {function} seededRandom\n */\nfunction turnFace(faceContainer, mouth, nose, leftEye, rightEye, seededRandom) {\n  // Between -.2 and .2\n  const direction = 0.4 * seededRandom() - 0.2;\n\n  // Between .8 and 1\n  faceContainer.scaleTo.x = 1 + Math.abs(direction);\n  // Because we don't have 3d drawing in pixi, we're just going to modify the eye and mouth positions/scales\n  // Between .8 and 1.2\n  mouth.scaleTo.x = 1 + direction;\n  mouth.positionTo.x = direction * 300;\n\n  nose.scaleTo.x = 1 - direction;\n  nose.positionTo.x = direction * 300;\n\n  leftEye.positionTo.x = direction * 300 - 80;\n  leftEye.scaleTo.x = Math.min(1 + direction * 2, 1.05);\n  rightEye.positionTo.x = direction * 300 + 80;\n  rightEye.scaleTo.x = Math.min(1 + direction * -2, 1.05);\n}\n\nfunction openMouth(mouth, seededRandom) {\n  // Between .45 and .55\n  mouth.scaleTo.y = 0.1 * seededRandom() + 0.5;\n}\n\n/**\n * Moves the irises of the eyes randomly\n *\n * @param {PIXI.Graphics} leftIris\n * @param {PIXI.Graphics} rightIris\n * @param {function} seededRandom\n */\nfunction moveIris(leftIris, rightIris, seededRandom) {\n  // Between -50 and 50\n  const xPosition = 100 * seededRandom() - 50;\n  // Between -25 and 25\n  const yPosition = 50 * seededRandom() - 25;\n\n  leftIris.positionTo.x = xPosition;\n  rightIris.positionTo.x = xPosition;\n  leftIris.positionTo.y = yPosition;\n  rightIris.positionTo.y = yPosition;\n}\n\n// if the face is currently blinking\nlet isBlinking = false;\n\n/**\n * Make the eyes blink\n *\n * @param {PIXI.Graphics} leftEye\n * @param {PIXI.Graphics} rightEye\n */\nfunction blink(leftEye, rightEye) {\n  leftEye.scaleTo.y = 0.1;\n  rightEye.scaleTo.y = 0.1;\n  isBlinking = true;\n\n  // unblink after 300ms\n  window.setTimeout(() => {\n    leftEye.scaleTo.y = 1;\n    rightEye.scaleTo.y = 1;\n    isBlinking = false;\n  }, 400);\n}\n\n/**\n * Generates a canvas with a fake face to feed into the tensor flow model\n */\nexport function generateFaceCanvas(seededRandom) {\n  // Setup the pixi application\n  const app = new Application({\n    width: 1000,\n    height: 1000,\n    backgroundColor: 0xffffff,\n    sharedTicker: true,\n    antialias: true,\n  });\n\n  app.start();\n\n  const faceContainer = new Graphics();\n  faceContainer.beginFill(0xcccccc).drawEllipse(0, 0, 200, 250).endFill();\n  faceContainer.position.set(app.renderer.width / 2, app.renderer.height / 2);\n  setUpMoveOnTick(faceContainer);\n\n  const leftEye = createEye(-80, -75, Math.PI / -12);\n  const rightEye = createEye(80, -75, Math.PI / 12);\n\n  const nose = new Graphics();\n  nose.beginFill(0xeeeeee).drawEllipse(0, 20, 20, 40).endFill();\n  setUpMoveOnTick(nose);\n\n  const mouth = new Graphics();\n  mouth.beginFill(0xdd3344).arc(0, 0, 100, 0, Math.PI);\n\n  mouth.position.set(0, 100);\n  mouth.scale.set(1, 0.5);\n  setUpMoveOnTick(mouth);\n\n  faceContainer.addChild(mouth, nose, leftEye, rightEye);\n  faceContainer.position.set(500, 500);\n  setUpMoveOnTick(mouth);\n\n  app.stage.addChild(faceContainer);\n\n  // Start with a random expression and position based on the seed\n  rotateFace(faceContainer, seededRandom);\n  turnFace(faceContainer, mouth, nose, leftEye, rightEye, seededRandom);\n  openMouth(mouth, seededRandom);\n  moveIris(leftEye.iris, rightEye.iris, seededRandom);\n\n  // Move them right before our first render\n  moveInstantly(faceContainer);\n  moveInstantly(mouth);\n  moveInstantly(nose);\n  moveInstantly(rightEye, { scaleY: 0.3 });\n  moveInstantly(rightEye.iris);\n  moveInstantly(leftEye, { scaleY: 0.3 });\n  moveInstantly(leftEye.iris);\n\n  app.render();\n\n  // Sets up an animation ticker for various ambient head movements and\n  Ticker.shared.add(() => {\n    const tickSeed = seededRandom();\n    // There's a 3% chance on every tick the face will rotate a different direction\n    if (tickSeed >= 0.98) {\n      rotateFace(faceContainer, seededRandom);\n    }\n    // There's a 5% chance on every tick the face will turn a different direction\n    // This is overlapping with rotation for smoother head movement\n    if (tickSeed >= 0.96) {\n      turnFace(faceContainer, mouth, nose, leftEye, rightEye, seededRandom);\n    }\n\n    // Change the mouth size occasionally (4%)\n    if (tickSeed >= 0.93 && tickSeed < 0.96) {\n      openMouth(mouth, seededRandom);\n    }\n    // Move the eyes occasionally (5%)\n    if (tickSeed >= 0.89 && tickSeed < 0.93) {\n      moveIris(leftEye.iris, rightEye.iris, seededRandom);\n    }\n    // Blink occasionally (1%)\n    if (tickSeed >= 0.88 && tickSeed < 0.89 && !isBlinking) {\n      blink(leftEye, rightEye);\n    }\n\n    // Change the scaling, rotation, and positions slowly (.1)\n    moveOnTick(faceContainer);\n    moveOnTick(mouth);\n    moveOnTick(nose);\n\n    // Blinking occurs faster\n    moveOnTick(rightEye, { scaleY: 0.3 });\n    moveOnTick(rightEye.iris);\n\n    // Blinking occurs faster\n    moveOnTick(leftEye, { scaleY: 0.3 });\n    moveOnTick(leftEye.iris);\n  });\n\n  return app.view;\n}\n","/**\n * Downloads the passed Canvas as a png.\n *\n * @param      {Canvas}   The Canvas\n * @return     {Promise}  { description_of_the_return_value }\n */\nexport async function downloadCanvasAsPNG(canvas, filename) {\n  const url = await new Promise((resolve) => {\n    // toBlob(callback, mimeType, qualityArgument);\n    canvas.toBlob(function (blob) {\n      resolve(URL.createObjectURL(blob));\n    }, \"image/png\");\n  });\n\n  var a = document.createElement(\"a\");\n  document.body.appendChild(a); // This line makes it work in Firefox.\n  a.setAttribute(\"download\", filename + \".png\");\n  a.setAttribute(\"href\", url);\n  a.setAttribute(\"target\", \"_blank\");\n  a.click();\n  // We don't need it anymore, remove it\n  a.remove();\n}\n","import \"./index.css\";\n\nimport {\n  Application,\n  Container,\n  Loader,\n  filters,\n  Ticker,\n  Spritesheet,\n  settings,\n  utils,\n  ENV,\n} from \"pixi.js\";\nimport { DotFilter } from \"@pixi/filter-dot\";\nimport { MultiColorReplaceFilter } from \"@pixi/filter-multi-color-replace\";\n\nimport seedrandom from \"seedrandom\";\n\nimport GooeyFilter from \"./GooeyFilter.js\";\nimport { drawFace, getFaceFromMedia, redrawFace } from \"./faceDrawing.js\";\nimport { contrast } from \"./utils.js\";\nimport { startWebcam } from \"./mediaSource.js\";\nimport { generateFaceCanvas } from \"./generateFace.js\";\n\nimport { downloadCanvasAsPNG } from \"./downloadFrame.js\";\nimport spritesheetJSON from \"./spritesheet.json\";\n\nrequire(\"@tensorflow/tfjs-backend-webgl\");\n\n// Pixi.js settings\nsettings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;\nsettings.PREFER_ENV = ENV.WEBGL_LEGACY;\nsettings.FILTER_RESOLUTION = 2;\n\nconst whiteTextureUrl = `${process.env.PUBLIC_URL}/sprite-sheet-white.png`;\n\n///////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n/////////////////////////////// Reference ////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n// http://bl.ocks.org/nbremer/0e98c72b043590769facc5e829ebf43f\n// http://bl.ocks.org/syntagmatic/6a921aed54be2a2bea5e56cf2157768b\n// https://www.visualcinnamon.com/2016/06/fun-data-visualizations-svg-gooey-effect\n\n///////////////////////////////////////////////////////////////////////////\n/////////////////////////////// Set-up ////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n// Set our random seed based on the \"seed\" query parameter supplied\nconst queryParams = new URLSearchParams(window.location.search);\nconst seed = parseInt(queryParams.get(\"seed\"));\nconst page = parseInt(queryParams.get(\"page\"));\nconst seededRandom = seed && page ? seedrandom(seed + page) : seedrandom();\n\nconst isDownload = queryParams.has(\"page\");\n\n// Use the w and h parameters to set a specfic height and width for the canvas (useful for generating and downloading images)\n// magic numbers are provided resolution\nconst width = page ? 2412 : Number(queryParams.get(\"w\")) || window.innerWidth;\nconst height = page ? 3074 : Number(queryParams.get(\"h\")) || window.innerHeight;\n\nconst bgColorArray = [seededRandom(), seededRandom(), seededRandom()];\n// Ensure the FG color has at least a contrast ratio of 4.5: 1 for legibility\n// https://www.w3.org/TR/WCAG20-TECHS/G18.html\nlet isContrastRatioAcceptable = false;\nlet fgColorArray;\nwhile (!isContrastRatioAcceptable) {\n  fgColorArray = [seededRandom(), seededRandom(), seededRandom()];\n  isContrastRatioAcceptable = contrast(bgColorArray, fgColorArray) >= 4.8;\n}\n\nconst bgColor = utils.rgb2hex(bgColorArray);\nconst fgColor = utils.rgb2hex(fgColorArray);\n\n// Setup the pixi application\nconst app = new Application({\n  width,\n  height,\n  antialias: true,\n  backgroundColor: bgColor,\n  sharedTicker: true,\n  sharedLoader: true,\n  // Only resize if we are not downloading\n  resizeTo: !isDownload ? window : undefined,\n});\nwindow.app = app;\n\napp.start();\n\n// We don't need the default pixi application render on tick call.\n// We will be managing our own render calls elsewhere\nTicker.shared.remove(app.render, app);\nTicker.shared.fps = 30;\n\nTicker.shared.start();\n// Add it to the body\ndocument.body.appendChild(app.view);\n\nasync function setup() {\n  let faceSource = null;\n\n  // If we're downloading the image, use our generated face\n  if (isDownload) {\n    faceSource = generateFaceCanvas(seededRandom);\n    // Otherwise attempt to get a webcam feed\n  } else {\n    try {\n      faceSource = await startWebcam();\n    } catch (error) {\n      console.info(\n        \"Cannot use webcam for source, falling back to default\",\n        error\n      );\n      // If this doesn't work, fallback to the generated face\n      faceSource = generateFaceCanvas(seededRandom);\n    }\n  }\n\n  // Grow circle and effect size proportional to the page size\n  const sizeFactor = 0.03 * Math.min(app.renderer.width, app.renderer.height);\n\n  const whiteTexture = Loader.shared.resources[whiteTextureUrl].texture;\n  const whiteSpriteSheet = new Spritesheet(whiteTexture, spritesheetJSON);\n\n  await Promise.all([\n    new Promise((resolve) => {\n      whiteSpriteSheet.parse(resolve);\n    }),\n  ]);\n\n  // Set a container for where all of the objects will be (so we can center and scale it on resize)\n  const faceContainer = new Container();\n  app.stage.addChild(faceContainer);\n  const featureContainer = new Container();\n  const iconContainer = new Container();\n  faceContainer.addChild(featureContainer, iconContainer);\n\n  // Add visual filters\n  const blurFilter = new filters.BlurFilter();\n  blurFilter.blur = sizeFactor;\n  blurFilter.quality = 7;\n\n  const gooeyFilter = new GooeyFilter();\n\n  const dotFilter = new DotFilter(1.05, 0);\n  const colorReplace = new MultiColorReplaceFilter(\n    [\n      [0xffffff, bgColor],\n      [0x000000, fgColor],\n    ],\n    0.1\n  );\n\n  featureContainer.filters = [blurFilter, gooeyFilter, dotFilter, colorReplace];\n  iconContainer.filters = [colorReplace];\n\n  // `predictions` is an array of objects describing each detected face\n  let predictions = [];\n  if (faceSource) {\n    predictions = await getFaceFromMedia(faceSource);\n  }\n\n  drawFace({\n    app,\n    seededRandom,\n    sizeFactor,\n    spritesheet: whiteSpriteSheet,\n    faceContainer,\n    featureContainer,\n    iconContainer,\n    prediction: predictions[0],\n  });\n\n  app.render();\n\n  // Now that we're loaded we can download if requested\n  if (isDownload) {\n    downloadCanvasAsPNG(app.view, seed + \"_\" + page);\n  } else if (faceSource) {\n    Ticker.shared.add(async () => {\n      const predictions = await getFaceFromMedia(faceSource);\n      if (predictions.length) {\n        redrawFace({\n          app,\n          faceContainer,\n          featureContainer,\n          prediction: predictions[0],\n        });\n\n        app.render();\n      }\n    });\n  }\n}\n\n// load our assets\nLoader.shared.add(whiteTextureUrl).load(setup);\n"],"sourceRoot":""}