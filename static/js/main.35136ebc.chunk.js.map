{"version":3,"sources":["GooeyShader.frag","GooeyFilter.js","utils.js","downloadFrame.js","index.js"],"names":["GooeyFilter","threshold","Filter","defaulVertexSrc","fragment","_threshold","uniforms","uThreshold","value","this","luminanace","r","g","b","a","map","v","Math","pow","contrast","rgb1","rgb2","lum1","lum2","max","min","downloadCanvasAsPNG","canvas","Promise","resolve","toBlob","blob","URL","createObjectURL","url","document","createElement","body","appendChild","setAttribute","click","remove","window","PIXI","settings","FILTER_RESOLUTION","fgColorArray","whiteTextureUrl","process","queryParams","URLSearchParams","location","search","seed","get","seededRandom","seedrandom","bgColorArray","isContrastRatioAcceptable","bgColor","utils","rgb2hex","fgColor","app","Application","width","innerWidth","height","innerHeight","antialias","resizeTo","backgroundColor","sharedTicker","sharedLoader","createPoint","point","size","xRel","yRel","circle","Graphics","beginFill","drawCircle","endFill","position","set","renderer","textureKey","whiteSpriteSheet","_frameKeys","round","length","iconTexture","textures","icon","Sprite","anchor","x","y","scale","visible","whiteTexture","Loader","shared","resources","texture","Spritesheet","spritesheetJSON","all","parse","key","faceContainer","Container","iconContainer","stage","addChild","blurFilter","filters","BlurFilter","blur","quality","gooeyFilter","dotFilter","DotFilter","colorReplace","MultiColorReplaceFilter","MESH_ANNOTATIONS","includes","feature","name","featureIcons","forEach","pointIndex","UV_COORDS","rotation","PI","containerBounds","getBounds","render","view","start","Ticker","add","load"],"mappings":"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","file":"static/js/main.35136ebc.chunk.js","sourcesContent":["export default \"// Based on Waterdrop shader from https://codepen.io/stefanweck/pen/Vbgeax\\nprecision highp float;\\n#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\nuniform float uThreshold;\\n\\nvoid main(void) {\\n    vec4 color = texture2D(uSampler, vTextureCoord);\\n    color.a = step(uThreshold, color.a);\\n    gl_FragColor = color;\\n}\";","import { Filter } from \"pixi.js\";\n\nimport fragment from \"./GooeyShader.frag\";\n\nclass GooeyFilter extends Filter {\n  constructor(threshold = 0.2) {\n    super(Filter.defaulVertexSrc, fragment);\n    this._threshold = threshold;\n    this.uniforms.uThreshold = this._threshold;\n  }\n\n  /**\n   * Sets the threshold for the amount of goooooo\n   *\n   * @member {Number}\n   * @default 0\n   */\n  set threshold(value) {\n    this._threshold = value;\n    this.uniforms.uThreshold = value;\n  }\n  get threshold() {\n    return this._threshold;\n  }\n}\n\nexport default GooeyFilter;\n","/**\n * Calculate the luminance (the intensity of light or brightness) of a color\n * https://stackoverflow.com/questions/9733288/how-to-programmatically-calculate-the-contrast-ratio-between-two-colors\n *\n * @param {Number} r The Red value from 0.0 to 1.0\n * @param {Number} g The Green value from 0.0 to 1.0\n * @param {Number} b The Blue value from 0.0 to 1.0\n */\nexport function luminanace(r, g, b) {\n  const a = [r * 255, g * 255, b * 255].map((v) => {\n    v /= 255;\n    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\n  });\n  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\n}\n\n/**\n * Calculate the contrast ratio of two color arrays\n * https://stackoverflow.com/questions/9733288/how-to-programmatically-calculate-the-contrast-ratio-between-two-colors\n * @param {Number[]} rgb1 A color array in a [r,g,b] format from 0.0 to 1.0\n * @param {Number[]} rgb2 A color array in a [r,g,b] format from 0.0 to 1.0\n */\nexport function contrast(rgb1, rgb2) {\n  const lum1 = luminanace(rgb1[0], rgb1[1], rgb1[2]);\n  const lum2 = luminanace(rgb2[0], rgb2[1], rgb2[2]);\n  const brightest = Math.max(lum1, lum2);\n  const darkest = Math.min(lum1, lum2);\n  return (brightest + 0.05) / (darkest + 0.05);\n}\n","/**\n * Downloads the passed Canvas as a png.\n *\n * @param      {Canvas}   The Canvas\n * @return     {Promise}  { description_of_the_return_value }\n */\nexport async function downloadCanvasAsPNG(canvas) {\n  const url = await new Promise((resolve) => {\n    // toBlob(callback, mimeType, qualityArgument);\n    canvas.toBlob(function (blob) {\n      resolve(URL.createObjectURL(blob));\n    }, \"image/png\");\n  });\n\n  var a = document.createElement(\"a\");\n  document.body.appendChild(a); // This line makes it work in Firefox.\n  a.setAttribute(\"download\", \"image.jpg\");\n  a.setAttribute(\"href\", url);\n  a.setAttribute(\"target\", \"_blank\");\n  a.click();\n  // We don't need it anymore, remove it\n  a.remove();\n}\n","import \"./index.css\";\n\nimport {\n  Application,\n  Container,\n  Graphics,\n  Loader,\n  filters,\n  Ticker,\n  Spritesheet,\n  Sprite,\n  settings,\n  utils,\n} from \"pixi.js\";\nimport * as PIXI from \"pixi.js\";\nimport { DotFilter } from \"@pixi/filter-dot\";\nimport { MultiColorReplaceFilter } from \"@pixi/filter-multi-color-replace\";\n\nimport { UV_COORDS } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/uv_coords.js\";\nimport { MESH_ANNOTATIONS } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/keypoints.js\";\n\nimport seedrandom from \"seedrandom\";\n\nimport GooeyFilter from \"./GooeyFilter.js\";\nimport { contrast } from \"./utils.js\";\n\nimport { downloadCanvasAsPNG } from \"./downloadFrame.js\";\nimport spritesheetJSON from \"./spritesheet.json\";\n\nwindow.PIXI = PIXI;\nsettings.FILTER_RESOLUTION = 2;\n\nconst whiteTextureUrl = `${process.env.PUBLIC_URL}/sprite-sheet-white.png`;\n// const blackTextureUrl = `${process.env.PUBLIC_URL}/sprite-sheet-black.png`\n\n///////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n/////////////////////////////// Reference ////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n// http://bl.ocks.org/nbremer/0e98c72b043590769facc5e829ebf43f\n// http://bl.ocks.org/syntagmatic/6a921aed54be2a2bea5e56cf2157768b\n// https://www.visualcinnamon.com/2016/06/fun-data-visualizations-svg-gooey-effect\n\n///////////////////////////////////////////////////////////////////////////\n/////////////////////////////// Set-up ////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n// Set our random seed based on the \"seed\" query parameter supplied\nconst queryParams = new URLSearchParams(window.location.search);\nconst seed = queryParams.get(\"seed\");\nconst seededRandom = seedrandom(seed);\n\nconst bgColorArray = [seededRandom(), seededRandom(), seededRandom()];\n// Ensure the FG color has at least a contrast ratio of 4.5: 1 for legibility\n// https://www.w3.org/TR/WCAG20-TECHS/G18.html\nlet isContrastRatioAcceptable = false;\nlet fgColorArray;\nwhile (!isContrastRatioAcceptable) {\n  fgColorArray = [seededRandom(), seededRandom(), seededRandom()];\n\n  isContrastRatioAcceptable = contrast(bgColorArray, fgColorArray) >= 4.5;\n}\n\nconst bgColor = utils.rgb2hex(bgColorArray);\nconst fgColor = utils.rgb2hex(fgColorArray);\n\n// Setup the pixi application\nconst app = new Application({\n  width: window.innerWidth,\n  height: window.innerHeight,\n  antialias: true,\n  resizeTo: window,\n  backgroundColor: bgColor,\n  sharedTicker: true,\n  sharedLoader: true,\n});\nwindow.app = app;\napp.start();\nTicker.shared.start();\n// Add it to the body\ndocument.body.appendChild(app.view);\n\nasync function setup() {\n  const whiteTexture = Loader.shared.resources[whiteTextureUrl].texture;\n  // const blackTexture = Loader.shared.resources[blackTextureUrl].texture\n\n  const whiteSpriteSheet = new Spritesheet(whiteTexture, spritesheetJSON);\n  // const blackSpriteSheet = new Spritesheet(blackTexture, spritesheetJSON)\n\n  await Promise.all([\n    new Promise((resolve) => {\n      whiteSpriteSheet.parse(resolve);\n    }),\n    // new Promise((resolve) => {blackSpriteSheet.parse(resolve)}),\n  ]);\n\n  // Set a container for where all of the objects will be (so we can center and scale it on resize)\n  const faceContainer = new Container();\n  const iconContainer = new Container();\n  app.stage.addChild(faceContainer, iconContainer);\n  faceContainer.position.set(app.renderer.width / 2, app.renderer.height / 2);\n  iconContainer.position = faceContainer.position;\n\n  // Add visual filters\n  const blurFilter = new filters.BlurFilter();\n  blurFilter.blur = 20;\n  blurFilter.quality = 10;\n\n  const gooeyFilter = new GooeyFilter();\n\n  const dotFilter = new DotFilter(1.05, 0);\n  window.dotFilter = dotFilter;\n  const colorReplace = new MultiColorReplaceFilter(\n    [\n      [0xffffff, bgColor],\n      [0x000000, fgColor],\n    ],\n    0.1\n  );\n\n  faceContainer.filters = [blurFilter, gooeyFilter, dotFilter, colorReplace];\n  iconContainer.filters = [colorReplace];\n\n  /**\n   * Add a point on the face mesh\n   *\n   * @param      {Number}  [size=seededRandom()*14+8]  The size\n   */\n  function createPoint(point, size = 1, color = 0xffffff) {\n    // The UV coords are normalized in terms of 0 -> 1 of the container\n    const [xRel, yRel] = point;\n    const circle = new Graphics()\n      .beginFill(0xffffff * seededRandom())\n      .drawCircle(0, 0, size)\n      .endFill();\n    // TODO: reposition on window resize\n    circle.position.set(\n      xRel * app.renderer.width - app.renderer.width / 2,\n      yRel * app.renderer.height - app.renderer.height / 2\n    );\n\n    const textureKey =\n      whiteSpriteSheet._frameKeys[\n        Math.round((whiteSpriteSheet._frameKeys.length - 1) * seededRandom())\n      ];\n    const iconTexture = whiteSpriteSheet.textures[textureKey];\n    const icon = new Sprite(iconTexture);\n    icon.anchor.set(0.5, 0.5);\n    icon.position.set(circle.x, circle.y);\n    icon.scale.set(\n      (size * 2 - 15) / Math.min(iconTexture.width, iconTexture.height)\n    );\n\n    // Hide icon if the size is smaller than 10 for visual fidelity\n    if (size < 10) {\n      icon.visible = false;\n    }\n\n    return [circle, icon];\n  }\n\n  // Add all of the important points\n  for (const key in MESH_ANNOTATIONS) {\n    if (!key.includes(\"Iris\") && !key.includes(\"silhouette\")) {\n      const feature = new Container();\n      feature.name = key;\n      const featureIcons = new Container();\n      featureIcons.name = `${key}_icons`;\n\n      MESH_ANNOTATIONS[key].forEach((pointIndex) => {\n        const [circle, icon] = createPoint(\n          UV_COORDS[pointIndex],\n          seededRandom() * 30\n        );\n        feature.addChild(circle);\n        featureIcons.addChild(icon);\n      });\n\n      feature.position.set(25 - seededRandom() * 50, 25 - seededRandom() * 50);\n      featureIcons.position = feature.position;\n\n      feature.scale.set(\n        1 + (0.2 - seededRandom() * 0.4),\n        1 + (0.2 - seededRandom() * 0.4)\n      );\n      featureIcons.scale = feature.scale;\n\n      feature.rotation = Math.PI / 8 - (seededRandom() * Math.PI) / 4;\n      featureIcons.rotation = feature.rotation;\n\n      faceContainer.addChild(feature);\n      iconContainer.addChild(featureIcons);\n    }\n  }\n\n  // Scale up the face so at least one edge is touching the sides\n  const containerBounds = faceContainer.getBounds();\n  const scale = Math.min(\n    1 + (app.renderer.width - containerBounds.width) / containerBounds.width,\n    1 + (app.renderer.height - containerBounds.height) / containerBounds.height\n  );\n  faceContainer.scale.set(scale);\n  iconContainer.scale.set(scale);\n\n  app.render();\n\n  // Now that we're loaded we can download if requested\n  if (queryParams.get(\"download\")) {\n    downloadCanvasAsPNG(app.view);\n  }\n}\n\n// load our assets\nLoader.shared\n  .add(whiteTextureUrl)\n  // .add(blackTextureUrl)\n  .load(setup);\n"],"sourceRoot":""}