{"version":3,"sources":["GooeyShader.frag","GooeyFilter.js","faceDrawing.js","utils.js","downloadFrame.js","index.js"],"names":["GooeyFilter","threshold","Filter","defaulVertexSrc","fragment","_threshold","uniforms","uThreshold","value","this","faceLandmarksDetection","require","getSizeFromBoundingBox","topLeft","bottomRight","width","height","getContainerSize","app","prediction","container","boundingBox","scale","Math","max","renderer","getCirclePosition","point","x","y","convertUVToContainer","convertMeshToRelative","scaledMesh","UV_COORDS","createPoint","size","spritesheet","seededRandom","circle","Graphics","beginFill","drawCircle","endFill","position","set","textureKey","_frameKeys","round","length","iconTexture","textures","icon","Sprite","anchor","finalScale","min","redrawFace","faceContainer","featureContainer","pivot","key","feature","getChildByName","includes","MESH_ANNOTATIONS","forEach","pointIndex","featurePoint","getChildAt","getLocalBounds","drawFace","sizeFactor","iconContainer","Container","name","featureIcons","circlePosition","visible","addChild","rotation","startWebcam","a","navigator","mediaDevices","getUserMedia","audio","video","stream","document","createElement","Promise","resolve","reject","addEventListener","play","srcObject","console","error","modelSingleton","getFaceFromMedia","load","SupportedPackages","mediapipeFacemesh","estimateFaces","input","predictIrises","luminanace","r","g","b","map","v","pow","contrast","rgb1","rgb2","lum1","lum2","downloadCanvasAsPNG","canvas","filename","toBlob","blob","URL","createObjectURL","url","body","appendChild","setAttribute","click","remove","window","PIXI","settings","FILTER_RESOLUTION","fgColorArray","whiteTextureUrl","process","queryParams","URLSearchParams","location","search","seed","parseInt","get","page","seedrandom","isDownload","has","Number","innerWidth","innerHeight","bgColorArray","isContrastRatioAcceptable","bgColor","utils","rgb2hex","fgColor","Application","antialias","backgroundColor","sharedTicker","sharedLoader","resizeTo","undefined","faceSource","info","whiteTexture","Loader","shared","resources","texture","whiteSpriteSheet","Spritesheet","spritesheetJSON","all","parse","stage","blurFilter","filters","BlurFilter","blur","quality","gooeyFilter","dotFilter","DotFilter","colorReplace","MultiColorReplaceFilter","predictions","render","view","Ticker","add","start","fps"],"mappings":"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","file":"static/js/main.769108b7.chunk.js","sourcesContent":["export default \"// Based on Waterdrop shader from https://codepen.io/stefanweck/pen/Vbgeax\\nprecision highp float;\\n#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\nuniform float uThreshold;\\n\\nvoid main(void) {\\n    vec4 color = texture2D(uSampler, vTextureCoord);\\n    color.a = step(uThreshold, color.a);\\n    gl_FragColor = color;\\n}\";","import { Filter } from \"pixi.js\";\n\nimport fragment from \"./GooeyShader.frag\";\n\nclass GooeyFilter extends Filter {\n  constructor(threshold = 0.2) {\n    super(Filter.defaulVertexSrc, fragment);\n    this._threshold = threshold;\n    this.uniforms.uThreshold = this._threshold;\n  }\n\n  /**\n   * Sets the threshold for the amount of goooooo\n   *\n   * @member {Number}\n   * @default 0\n   */\n  set threshold(value) {\n    this._threshold = value;\n    this.uniforms.uThreshold = value;\n  }\n  get threshold() {\n    return this._threshold;\n  }\n}\n\nexport default GooeyFilter;\n","import { Container, Graphics, Sprite } from \"pixi.js\";\nimport { UV_COORDS } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/uv_coords.js\";\nimport { MESH_ANNOTATIONS } from \"@tensorflow-models/face-landmarks-detection/dist/mediapipe-facemesh/keypoints.js\";\nconst faceLandmarksDetection = require(\"@tensorflow-models/face-landmarks-detection\");\n\n/**\n * Gets the size from out tensor flow bounding box\n *\n * @param {Object} boundingBox\n * @param {Number} boundingBox.topLeft The top left coordinate of the container\n * @param {Number} boundingBox.bottomRight The bottom right coordinate of the container\n */\nexport function getSizeFromBoundingBox({ topLeft, bottomRight }) {\n  return {\n    width: bottomRight[0] - topLeft[0],\n    height: bottomRight[1] - topLeft[1],\n  };\n}\n\n/**\n * The UV coords are normalized in terms of 0 -> 1 of the container\n * Convert the relative values to pixels in the container\n *\n * @param {Array} point\n * @param {Number} point[0] The x value of the point\n * @param {Number} point[1] The y value of the point\n * @param {Array} containerSize\n * @param {Number} containerSize[0] The width value of the container\n * @param {Number} containerSize[1] The height value of the container\n */\nfunction convertUVToContainer([x, y], [width, height]) {\n  return [x * width, y * height];\n}\n\n/**\n * Converts the tensor flow mesh to a relative (0->1) position\n *\n * @param {Array} point\n * @param {Number} point[0] The x value of the point\n * @param {Number} point[1] The y value of the point\n * @param {Object} boundingBox\n * @param {Number} boundingBox.topLeft The top left coordinate of the container\n * @param {Number} boundingBox.bottomRight The bottom right coordinate of the container\n */\nfunction convertMeshToRelative([x, y], boundingBox) {\n  const { width, height } = getSizeFromBoundingBox(boundingBox);\n  return [\n    (x - boundingBox.topLeft[0]) / width,\n    (y - boundingBox.topLeft[1]) / height,\n  ];\n}\n\nfunction getContainerSize(app, prediction) {\n  let container = [];\n  if (prediction) {\n    const { width, height } = getSizeFromBoundingBox(prediction.boundingBox);\n    const scale = Math.max(\n      app.renderer.width / width,\n      app.renderer.height / height\n    );\n    container = [width * scale, height * scale];\n  } else {\n    container = [app.renderer.width, app.renderer.height];\n  }\n\n  return container;\n}\n\nfunction getCirclePosition(point, prediction, container) {\n  // If the point is an array it's xyz coords, otherwise it's an index reference to UV_COORDS\n  let relativeCoords = [];\n  if (prediction) {\n    relativeCoords = convertMeshToRelative(\n      prediction.scaledMesh[point],\n      prediction.boundingBox\n    );\n  } else {\n    relativeCoords = UV_COORDS[point];\n  }\n  return convertUVToContainer(relativeCoords, container);\n}\n\n/**\n * Add a point on the face mesh\n */\nexport function createPoint(point, size, spritesheet, seededRandom) {\n  const circle = new Graphics()\n    .beginFill(0xffffff * seededRandom())\n    .drawCircle(0, 0, size)\n    .endFill();\n  // TODO: reposition on window resize\n  circle.position.set(...point);\n\n  const textureKey =\n    spritesheet._frameKeys[\n      Math.round((spritesheet._frameKeys.length - 1) * seededRandom())\n    ];\n  const iconTexture = spritesheet.textures[textureKey];\n  const icon = new Sprite(iconTexture);\n  icon.anchor.set(0.5, 0.5);\n  icon.position.set(circle.x, circle.y);\n  icon.finalScale =\n    (size * 1.1) / Math.min(iconTexture.width, iconTexture.height);\n  icon.scale.set(icon.finalScale);\n\n  // Store the circle so we can reference it in the animation\n  icon.circle = circle;\n  circle.icon = icon;\n\n  return [circle, icon];\n}\n\nexport function redrawFace({\n  app,\n  faceContainer,\n  featureContainer,\n  prediction,\n}) {\n  const container = getContainerSize(app, prediction);\n\n  // Center the face in the window, but move it slowly to reduce jitter\n  faceContainer.pivot.set(\n    faceContainer.pivot.x - (faceContainer.pivot.x - container[0] / 2) * 0.1,\n    faceContainer.pivot.y - (faceContainer.pivot.y - container[1] / 2) * 0.1\n  );\n  faceContainer.position.set(\n    faceContainer.position.x -\n      (faceContainer.position.x - app.renderer.width / 2) * 0.1,\n    faceContainer.position.y -\n      (faceContainer.position.y - app.renderer.height / 2) * 0.1\n  );\n\n  for (const key in MESH_ANNOTATIONS) {\n    const feature = featureContainer.getChildByName(key);\n    // Only draw irises if we have a prediction (otherwise we don't have UV poiunts for irises)\n    // Don't draw the silhouette either\n    if (\n      (prediction && key.includes(\"Iris\")) ||\n      (!key.includes(\"silhouette\") && !key.includes(\"Iris\"))\n    ) {\n      MESH_ANNOTATIONS[key].forEach((point, pointIndex) => {\n        const featurePoint = feature.getChildAt(pointIndex);\n\n        const position = getCirclePosition(point, prediction, container);\n\n        // Move slowly to the point to reduce jitter\n        featurePoint.position.set(\n          featurePoint.position.x -\n            (featurePoint.position.x - position[0]) * 0.1,\n          featurePoint.position.y -\n            (featurePoint.position.y - position[1]) * 0.1\n        );\n        featurePoint.icon.position.set(featurePoint.x, featurePoint.y);\n      });\n    }\n  }\n\n  const { width, height } = faceContainer.getLocalBounds();\n  // Set the scale so at least some of the edges touch the sides\n  const scale =\n    Math.min(app.renderer.width / width, app.renderer.height / height) * 1.05;\n  // Scale it slowly to reduce jitter\n  faceContainer.scale.set(\n    faceContainer.scale.x - (faceContainer.scale.x - scale) * 0.1\n  );\n}\n\nexport function drawFace({\n  app,\n  seededRandom,\n  sizeFactor,\n  spritesheet,\n  faceContainer,\n  featureContainer,\n  iconContainer,\n  prediction,\n}) {\n  const container = getContainerSize(app, prediction);\n\n  // Center the face in the window\n  faceContainer.pivot.set(container[0] / 2, container[1] / 2);\n  faceContainer.position.set(app.renderer.width / 2, app.renderer.height / 2);\n\n  // Add all of the important points\n  for (const key in MESH_ANNOTATIONS) {\n    // Only draw irises if we have a prediction (otherwise we don't have UV poiunts for irises)\n    // Don't draw the silhouette either\n    if (\n      (prediction && key.includes(\"Iris\")) ||\n      (!key.includes(\"silhouette\") && !key.includes(\"Iris\"))\n    ) {\n      const feature = new Container();\n      feature.name = key;\n      const featureIcons = new Container();\n      featureIcons.name = `${key}_icons`;\n\n      MESH_ANNOTATIONS[key].forEach((point, pointIndex) => {\n        const circlePosition = getCirclePosition(point, prediction, container);\n\n        // Grow size proportional to the page size\n        const size = seededRandom() * sizeFactor;\n\n        const [circle, icon] = createPoint(\n          circlePosition,\n          size,\n          spritesheet,\n          seededRandom\n        );\n\n        // Hide icon if the size is smaller than 1/3rd of the sizeFactor for visual fidelity\n        if (size < sizeFactor / 3) {\n          icon.visible = false;\n        }\n\n        circle.name = pointIndex;\n        icon.name = pointIndex;\n        feature.addChild(circle);\n        featureIcons.addChild(icon);\n      });\n\n      featureIcons.position = feature.position;\n      featureIcons.pivot = feature.pivot;\n      featureIcons.scale = feature.scale;\n      featureIcons.rotation = feature.rotation;\n\n      featureContainer.addChild(feature);\n      iconContainer.addChild(featureIcons);\n    }\n  }\n\n  const { width, height } = faceContainer.getLocalBounds();\n  // Set the scale so at least some of the edges touch the sides\n  const scale =\n    Math.min(app.renderer.width / width, app.renderer.height / height) * 1.05;\n  // Scale it slowly to reduce jitter\n  faceContainer.scale.set(scale);\n}\n\nexport async function startWebcam() {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: false,\n      video: true,\n    });\n    const video = document.createElement(\"video\");\n    // TODO: Reject on timeout\n    await new Promise((resolve, reject) => {\n      video.addEventListener(\"loadedmetadata\", async () => {\n        await video.play();\n        resolve();\n      });\n      video.srcObject = stream;\n    });\n\n    return video;\n  } catch (error) {\n    console.error(\"Cannot access a webcam: \", error);\n  }\n  return null;\n}\n\nlet modelSingleton = null;\nexport async function getFaceFromMedia(video) {\n  if (!modelSingleton) {\n    modelSingleton = await faceLandmarksDetection.load(\n      faceLandmarksDetection.SupportedPackages.mediapipeFacemesh\n    );\n  }\n\n  return modelSingleton.estimateFaces({\n    input: video,\n    predictIrises: true,\n  });\n}\n","/**\n * Calculate the luminance (the intensity of light or brightness) of a color\n * https://stackoverflow.com/questions/9733288/how-to-programmatically-calculate-the-contrast-ratio-between-two-colors\n *\n * @param {Number} r The Red value from 0.0 to 1.0\n * @param {Number} g The Green value from 0.0 to 1.0\n * @param {Number} b The Blue value from 0.0 to 1.0\n */\nexport function luminanace(r, g, b) {\n  const a = [r * 255, g * 255, b * 255].map((v) => {\n    v /= 255;\n    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\n  });\n  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;\n}\n\n/**\n * Calculate the contrast ratio of two color arrays\n * https://stackoverflow.com/questions/9733288/how-to-programmatically-calculate-the-contrast-ratio-between-two-colors\n * @param {Number[]} rgb1 A color array in a [r,g,b] format from 0.0 to 1.0\n * @param {Number[]} rgb2 A color array in a [r,g,b] format from 0.0 to 1.0\n */\nexport function contrast(rgb1, rgb2) {\n  const lum1 = luminanace(rgb1[0], rgb1[1], rgb1[2]);\n  const lum2 = luminanace(rgb2[0], rgb2[1], rgb2[2]);\n  const brightest = Math.max(lum1, lum2);\n  const darkest = Math.min(lum1, lum2);\n  return (brightest + 0.05) / (darkest + 0.05);\n}\n","/**\n * Downloads the passed Canvas as a png.\n *\n * @param      {Canvas}   The Canvas\n * @return     {Promise}  { description_of_the_return_value }\n */\nexport async function downloadCanvasAsPNG(canvas, filename) {\n  const url = await new Promise((resolve) => {\n    // toBlob(callback, mimeType, qualityArgument);\n    canvas.toBlob(function (blob) {\n      resolve(URL.createObjectURL(blob));\n    }, \"image/png\");\n  });\n\n  var a = document.createElement(\"a\");\n  document.body.appendChild(a); // This line makes it work in Firefox.\n  a.setAttribute(\"download\", filename + \".png\");\n  a.setAttribute(\"href\", url);\n  a.setAttribute(\"target\", \"_blank\");\n  a.click();\n  // We don't need it anymore, remove it\n  a.remove();\n}\n","import \"./index.css\";\n\nimport {\n  Application,\n  Container,\n  Loader,\n  filters,\n  Ticker,\n  Spritesheet,\n  settings,\n  utils,\n} from \"pixi.js\";\nimport * as PIXI from \"pixi.js\";\nimport { DotFilter } from \"@pixi/filter-dot\";\nimport { MultiColorReplaceFilter } from \"@pixi/filter-multi-color-replace\";\n\nimport seedrandom from \"seedrandom\";\n\nimport GooeyFilter from \"./GooeyFilter.js\";\nimport {\n  drawFace,\n  startWebcam,\n  getFaceFromMedia,\n  redrawFace,\n} from \"./faceDrawing.js\";\nimport { contrast } from \"./utils.js\";\n\nimport { downloadCanvasAsPNG } from \"./downloadFrame.js\";\nimport spritesheetJSON from \"./spritesheet.json\";\n\nrequire(\"@tensorflow/tfjs-backend-webgl\");\n\nwindow.PIXI = PIXI;\nsettings.FILTER_RESOLUTION = 2;\n\nconst whiteTextureUrl = `${process.env.PUBLIC_URL}/sprite-sheet-white.png`;\n\n///////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n/////////////////////////////// Reference ////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n// http://bl.ocks.org/nbremer/0e98c72b043590769facc5e829ebf43f\n// http://bl.ocks.org/syntagmatic/6a921aed54be2a2bea5e56cf2157768b\n// https://www.visualcinnamon.com/2016/06/fun-data-visualizations-svg-gooey-effect\n\n///////////////////////////////////////////////////////////////////////////\n/////////////////////////////// Set-up ////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n// Set our random seed based on the \"seed\" query parameter supplied\nconst queryParams = new URLSearchParams(window.location.search);\nconst seed = parseInt(queryParams.get(\"seed\"));\nconst page = parseInt(queryParams.get(\"page\"));\nconst seededRandom = seed && page ? seedrandom(seed + page) : seedrandom();\n\nconst isDownload = queryParams.has(\"page\");\n\n// Use the w and h parameters to set a specfic height and width for the canvas (useful for generating and downloading images)\n// magic numbers are provided resolution\nconst width = page ? 2412 : Number(queryParams.get(\"w\")) || window.innerWidth;\nconst height = page ? 3074 : Number(queryParams.get(\"h\")) || window.innerHeight;\n\nconst bgColorArray = [seededRandom(), seededRandom(), seededRandom()];\n// Ensure the FG color has at least a contrast ratio of 4.5: 1 for legibility\n// https://www.w3.org/TR/WCAG20-TECHS/G18.html\nlet isContrastRatioAcceptable = false;\nlet fgColorArray;\nwhile (!isContrastRatioAcceptable) {\n  fgColorArray = [seededRandom(), seededRandom(), seededRandom()];\n  isContrastRatioAcceptable = contrast(bgColorArray, fgColorArray) >= 4.8;\n}\n\nconst bgColor = utils.rgb2hex(bgColorArray);\nconst fgColor = utils.rgb2hex(fgColorArray);\n\n// Setup the pixi application\nconst app = new Application({\n  width,\n  height,\n  antialias: true,\n  backgroundColor: bgColor,\n  sharedTicker: true,\n  sharedLoader: true,\n  // Only resize if we are not downloading\n  resizeTo: !isDownload ? window : undefined,\n});\nwindow.app = app;\n\napp.start();\n\n// We don't need the default pixi application render on tick call.\n// We will be managing our own render calls elsewhere\nTicker.shared.remove(app.render, app);\nTicker.shared.fps = 30;\n\nTicker.shared.start();\n// Add it to the body\ndocument.body.appendChild(app.view);\n\nasync function setup() {\n  let faceSource = null;\n  if (!isDownload) {\n    try {\n      faceSource = await startWebcam();\n    } catch (e) {\n      console.info(\"Cannot use webcam for source, falling back to default\");\n    }\n  }\n\n  // Grow circle and effect size proportional to the page size\n  const sizeFactor = 0.03 * Math.min(app.renderer.width, app.renderer.height);\n\n  const whiteTexture = Loader.shared.resources[whiteTextureUrl].texture;\n  const whiteSpriteSheet = new Spritesheet(whiteTexture, spritesheetJSON);\n\n  await Promise.all([\n    new Promise((resolve) => {\n      whiteSpriteSheet.parse(resolve);\n    }),\n  ]);\n\n  // Set a container for where all of the objects will be (so we can center and scale it on resize)\n  const faceContainer = new Container();\n  app.stage.addChild(faceContainer);\n  const featureContainer = new Container();\n  const iconContainer = new Container();\n  faceContainer.addChild(featureContainer, iconContainer);\n\n  // Add visual filters\n  const blurFilter = new filters.BlurFilter();\n  blurFilter.blur = sizeFactor;\n  blurFilter.quality = 7;\n\n  const gooeyFilter = new GooeyFilter();\n\n  const dotFilter = new DotFilter(1.05, 0);\n  const colorReplace = new MultiColorReplaceFilter(\n    [\n      [0xffffff, bgColor],\n      [0x000000, fgColor],\n    ],\n    0.1\n  );\n\n  featureContainer.filters = [blurFilter, gooeyFilter, dotFilter, colorReplace];\n  iconContainer.filters = [colorReplace];\n\n  // `predictions` is an array of objects describing each detected face\n  let predictions = [];\n  if (faceSource) {\n    predictions = await getFaceFromMedia(faceSource);\n  }\n\n  drawFace({\n    app,\n    seededRandom,\n    sizeFactor,\n    spritesheet: whiteSpriteSheet,\n    faceContainer,\n    featureContainer,\n    iconContainer,\n    prediction: predictions[0],\n  });\n\n  app.render();\n\n  // Now that we're loaded we can download if requested\n  if (isDownload) {\n    downloadCanvasAsPNG(app.view, seed + \"_\" + page);\n  } else if (faceSource) {\n    Ticker.shared.add(async () => {\n      const predictions = await getFaceFromMedia(faceSource);\n      if (predictions.length) {\n        redrawFace({\n          app,\n          faceContainer,\n          featureContainer,\n          prediction: predictions[0],\n        });\n\n        app.render();\n      }\n    });\n  }\n}\n\n// load our assets\nLoader.shared.add(whiteTextureUrl).load(setup);\n"],"sourceRoot":""}